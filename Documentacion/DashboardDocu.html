<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Documentación del Proyecto - Docker Pulse</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Inter', sans-serif; }
        
        pre {
            background-color: #f3f4f6;
            padding: 1rem;
            border-radius: 0.5rem;
            border: 1px solid #e5e7eb;
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        .cmd-terminal {
            background-color: #1e1e1e;
            color: #d4d4d4;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            border: 1px solid #333;
            border-radius: 0.5rem;
            padding: 1.5rem;
            font-size: 0.9rem;
            line-height: 1.5;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.5);
            overflow-x: auto; 
        }

        .cmd-path { color: #4ec9b0; }
        .cmd-command { color: #dcdcaa; }
        .cmd-output { color: #cccccc; }
        .cmd-success { color: #6a9955; }
        .cmd-highlight { color: #569cd6; font-weight: bold; }
        
        code {
            font-family: 'Menlo', 'Monaco', 'Courier New', monospace;
            font-size: 0.9em;
        }

        /* Clase existente que usaremos para las capturas */
        .code-img {
            width: 100%;
            height: auto;
            border-radius: 0.375rem;
            border: 1px solid #e5e7eb;
            display: block; /* Asegura comportamiento de bloque */
            margin-top: 1rem;
        }
    </style>
</head>
<body class="bg-white text-gray-800">

    <div class="container mx-auto p-4 sm:p-6 lg:p-8">
        
        <header class="text-left mb-10 md:mb-12 pb-8 border-b">
            <h1 class="text-4xl md:text-5xl font-bold text-gray-900 tracking-tight">Documentación: Docker Pulse</h1>
            <p class="mt-4 text-lg text-gray-600 max-w-4xl">
                Registro del desarrollo de un gestor de contenedores Docker con monitoreo en tiempo real, terminal web y control de ciclo de vida.
            </p>
        </header>

<section class="mb-20">
    <h2 class="text-4xl font-bold mb-8 flex items-center">
        <span class="bg-orange-600 text-white text-sm px-3 py-1 rounded-full mr-3">Parte 1</span>
        Configuración del Entorno y Pasos Previos
    </h2>

    <div class="space-y-12">

        <div>
            <h3 class="text-2xl font-semibold text-gray-800 mb-4">1.1 Estructura del Proyecto (Cliente/Servidor)</h3>
            <p class="text-gray-600 mb-5">
                La aplicación consta de dos partes: Backend (Node.js) y Frontend (Vite + React).
            </p>
            <div class="cmd-terminal">
                <div><span class="cmd-path">~></span> <span class="cmd-command">mkdir docker-pulse</span></div>
                <div><span class="cmd-path">~></span> <span class="cmd-command">cd docker-pulse</span></div>
                <div><span class="cmd-path">~/docker-pulse></span> <span class="cmd-command">mkdir server client</span></div>
                <div><span class="cmd-path">~/docker-pulse/client></span> <span class="cmd-command">npm create vite@latest . -- --template react</span></div>
            </div>
        </div>

        <div>
            <h3 class="text-2xl font-semibold text-gray-800 mb-4">1.2 Instalación de dependencias</h3>
            <p class="text-gray-600 mb-5">
                Instala las librerías necesarias tanto para el servidor (API Docker) como para el cliente (UI y Terminal).
            </p>
            <div class="cmd-terminal">
                <div><span class="cmd-path">~/docker-pulse/server></span> <span class="cmd-command">npm install express socket.io dockerode cors</span></div>
                <div class="cmd-output"># dockerode → comunicación con Docker Engine</div>
                <div class="cmd-output"># socket.io → datos en tiempo real</div>
                <br>
                <div><span class="cmd-path">~/docker-pulse/client></span> <span class="cmd-command">npm install socket.io-client recharts xterm xterm-addon-fit lucide-react</span></div>
                <div class="cmd-output"># xterm → terminal web VT100</div>
                <div class="cmd-output"># recharts → gráficas de CPU/RAM</div>
            </div>
        </div>

        <div>
            <h3 class="text-2xl font-semibold text-gray-800 mb-4">1.3 Iniciar el Backend</h3>
            <p class="text-gray-600 mb-5">
                El servidor conecta con el socket de Docker y expone la API y WebSockets.
            </p>
            <div class="cmd-terminal">
                <div><span class="cmd-path">~/docker-pulse/server></span> <span class="cmd-command">node index.js</span></div>
                <div class="cmd-success">Server running on port 3000</div>
                <div class="cmd-success">Docker socket connected</div>
            </div>
        </div>

        <div class="bg-amber-50 border border-amber-200 rounded-lg p-6">
            <h3 class="text-2xl font-semibold text-gray-800 mb-4 flex items-center">
                <svg class="w-6 h-6 mr-2 text-amber-600" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z"/></svg>
                1.4 Crear Contenedor de Prueba (Obligatorio)
            </h3>
            <p class="text-gray-700 mb-4">
                Si no tienes contenedores corriendo, la aplicación aparecerá vacía. Ejecuta este comando en tu terminal para crear un contenedor nginx de prueba:
            </p>
            <pre class="bg-gray-900 text-gray-100 p-5 rounded-lg overflow-x-auto text-sm">
docker run -d --name demo-nginx -p 8080:80 nginx
            </pre>
            <p class="text-sm text-amber-700 mt-4">
                Esto descargará la imagen de nginx y levantará un contenedor accesible en el puerto 8080, visible inmediatamente en Docker Pulse.
            </p>
        </div>

        <div>
            <h3 class="text-2xl font-semibold text-gray-800 mb-4">1.5 Ejecutar el Frontend</h3>
            <div class="cmd-terminal">
                <div><span class="cmd-path">~/docker-pulse/client></span> <span class="cmd-command">npm run dev</span></div>
                <div class="cmd-output">Local:    http://localhost:5173</div>
            </div>
            <p class="text-gray-600 mt-4">
                Abre el enlace para ver el Dashboard con los semáforos de estado y gráficas.
            </p>
        </div>

    </div>
</section>

        <hr class="my-12 border-gray-200">

        <main class="space-y-16">
            <div class="mb-8">
                <h2 class="text-3xl font-bold text-gray-900 mb-2 flex items-center">
                    <span class="bg-red-600 text-white text-sm px-3 py-1 rounded-full mr-3">Parte 2</span>
                    Historial de Prompts 
                </h2>
                <p class="text-gray-600">Evolución paso a paso del proyecto, desde la definición del MVP hasta la refactorización de la UI.</p>
            </div>

            <section class="p-6 border border-gray-200 rounded-lg shadow-sm">
                <h3 class="text-2xl font-semibold text-gray-900 mb-2">Prompt 1: Definición Inicial</h3>
                <p class="text-gray-600 mb-4">Establecimiento de la idea general y requisitos para aplanar el terreno para los futuros contenidos</p>
                <div class="bg-gray-50 p-4 rounded-md border border-gray-200 mb-4">
                    <pre><code>Quiero hacer una aplicacion que compruebe contenedores dockers que tengo. Tiene que comprobar los datos de este docker, como su nombre y otras caracteristicas que lo componen. Se mostraran a la izquierda como un navegador y solo se mostraran los datos mas avanzados uan vez le hagass click</code></pre>
                </div>
                <div class="mt-6">
                    <span class="text-xs font-semibold text-gray-400 uppercase tracking-wider">Resultado Prompt 1:</span>
                    <img src="../FotosDocumentacion/fotos-Dashboard/prompt1.png" style="width:830px; height:430px; object-fit:cover;" alt="Captura Prompt 1 - Diseño Inicial" class="code-img">
                </div>
            </section>

            <section class="p-6 border border-gray-200 rounded-lg shadow-sm">
                <h3 class="text-2xl font-semibold text-gray-900 mb-2">Prompt 2: Implementación Técnica</h3>
                <p class="text-gray-600 mb-4">Definición de arquitectura Cliente-Servidor y uso de librería Dockerode.</p>
                <div class="bg-gray-50 p-4 rounded-md border border-gray-200 mb-4">
                    <pre><code>Procede con la creación de estructura server y client, instalación de dockerode, socket.io y xterm</code></pre>
                </div>
                <div class="mt-6">
                    <span class="text-xs font-semibold text-gray-400 uppercase tracking-wider">Resultado Prompt 2:</span>
                    <img src="../FotosDocumentacion/fotos-Dashboard/prompt2.png" style="width:430px; height:430px; object-fit:cover;" alt="Captura Prompt 2 - Estructura Archivos" class="code-img">
                </div>
            </section>

            <section class="p-6 border border-gray-200 rounded-lg shadow-sm">
                <h3 class="text-2xl font-semibold text-gray-900 mb-2">Prompt 3: Creación de funcionalidades de datos avanzados</h3>
                <p class="text-gray-600 mb-4">Crear las funciones como mostrar logs, los datos y la terminal integrada</p>
                <div class="bg-gray-50 p-4 rounded-md border border-gray-200 mb-4">
                    <pre><code>"Integra la capacidad de mostrar los recursos que tiene el contenedor, permitiendo encenderlo y apagarlo desde la aplicación, ademas añade un registro de los logs del contenedor y una terminal para ejecutar comandos directamente en este"</code></pre>
                </div>
                <div class="mt-6">
                    <span class="text-xs font-semibold text-gray-400 uppercase tracking-wider">Resultado Prompt 3:</span>
                    <img src="../FotosDocumentacion/fotos-Dashboard/prompt3.png" style="width:1430px; height:430px; object-fit:cover;" alt="Captura Prompt 3 - Primer Contenedor" class="code-img">
                </div>
            </section>

            <section class="p-6 border border-gray-200 rounded-lg shadow-sm">
                <h3 class="text-2xl font-semibold text-gray-900 mb-2">Prompt 4: Lanzamiento y comprobaciones</h3>
                <p class="text-gray-600 mb-4">Solución de errores del backend y comprobaciones para el correcto lanzamiento de la aplicación</p>
                <div class="bg-gray-50 p-4 rounded-md border border-gray-200 mb-4">
                    <pre><code>"Comprueba los errores de lanzamiento al abrir le backend y comprueba que no se vean errores graficos por algun error a la hora de ejecutar las librerias de Vite"</code></pre>
                </div>
                <div class="mt-6">
                    <span class="text-xs font-semibold text-gray-400 uppercase tracking-wider">Resultado Prompt 4:</span>
                    <img src="../FotosDocumentacion/fotos-Dashboard/prompt4.png" style="width:430px; height:430px; object-fit:cover;" alt="Captura Prompt 4 - Corrección Errores" class="code-img">
                </div>
            </section>

        </main>

        <hr class="my-12 border-gray-200">
<main class="space-y-16">
            <div class="mb-8">
                <h2 class="text-3xl font-bold text-gray-900 mb-2 flex items-center">
                    <span class="bg-blue-600 text-white text-sm px-3 py-1 rounded-full mr-3">Parte 3</span>
                    Galería de Código y Lógica Interna
                </h2>
                <p class="text-gray-600 mb-8">
                    Análisis profundo de la implementación técnica basado en la arquitectura BFF (Backend for Frontend).
                </p>

                <h3 class="text-2xl font-bold text-gray-800 mb-4 border-b pb-2">3.1. Arquitectura y Backend</h3>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-6 mb-10">
                    
                    <div class="bg-white p-4 rounded-lg border border-gray-200 shadow-sm">
                        <h4 class="font-bold text-gray-800 mb-2">API Rest: Listado y Enriquecimiento</h4>
                        <pre><code>// server/index.js
app.get('/api/containers', async (req, res) => {
  const containers = await docker.listContainers({ all: true });
  // Inspección profunda para sacar límites OOM y RAM
  const fullData = await Promise.all(containers.map(async (c) => {
    const container = docker.getContainer(c.Id);
    const data = await container.inspect();
    return { ...c, oomKilled: data.State.OOMKilled };
  }));
  res.json(fullData);
});</code></pre>
                        <p class="text-sm text-gray-500 mt-2">Obtiene la lista básica y realiza un <code>inspect()</code> adicional por cada contenedor para detectar si fue eliminado por falta de memoria (OOM).</p>
                    </div>

                    <div class="bg-white p-4 rounded-lg border border-gray-200 shadow-sm">
                        <h4 class="font-bold text-gray-800 mb-2">Streaming de Stats (WebSockets)</h4>
                        <pre><code>// server/index.js (Socket.io Namespace)
io.of('/stats').on('connection', (socket) => {
  container.stats({ stream: true }, (err, stream) => {
    stream.on('data', (chunk) => {
      // Docker envía JSON continuo
      const stats = JSON.parse(chunk.toString());
      socket.emit('stats', stats); 
    });
  });
});</code></pre>
                        <p class="text-sm text-gray-500 mt-2">Mantiene un canal abierto para enviar métricas crudas de Docker al frontend en tiempo real.</p>
                    </div>
                </div>

                <h3 class="text-2xl font-bold text-gray-800 mb-4 border-b pb-2">3.2. Lógica de Frontend</h3>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-6 mb-10">
                    
                    <div class="bg-white p-4 rounded-lg border border-gray-200 shadow-sm">
                        <h4 class="font-bold text-gray-800 mb-2">Polling de Estado (App.jsx)</h4>
                        <pre><code>useEffect(() => {
    fetchContainers();
    // Actualiza la lista cada 3 segundos
    const interval = setInterval(fetchContainers, 3000); 
    return () => clearInterval(interval);
}, []);</code></pre>
                        <p class="text-sm text-gray-500 mt-2">Mantiene la lista de contenedores sincronizada (estado Up/Exited) mediante peticiones periódicas.</p>
                    </div>

                    <div class="bg-white p-4 rounded-lg border border-gray-200 shadow-sm">
                        <h4 class="font-bold text-gray-800 mb-2">Cálculo de CPU (StatsGraph.jsx)</h4>
                        <pre><code>socket.on('stats', (stat) => {
  // Fórmula diferencial de Docker
  const cpuDelta = stat.cpu_stats.cpu_usage.total_usage - stat.precpu_stats.cpu_usage.total_usage;
  const systemDelta = stat.cpu_stats.system_cpu_usage - stat.precpu_stats.system_cpu_usage;
  
  if (systemDelta > 0 && cpuDelta > 0) {
      cpuPercent = (cpuDelta / systemDelta) * numCpus * 100.0;
  }
});</code></pre>
                        <p class="text-sm text-gray-500 mt-2">Transforma los "ticks" crudos del sistema en un porcentaje de uso de CPU legible para humanos.</p>
                    </div>

                    <div class="bg-white p-4 rounded-lg border border-gray-200 shadow-sm">
                        <h4 class="font-bold text-gray-800 mb-2">Terminal Web (WebTerminal.jsx)</h4>
                        <pre><code>import { Terminal } from 'xterm';

// Conexión bidireccional socket <-> xterm
socket.on('terminal-output', (data) => {
    term.write(data);
});
term.onData((data) => {
    socket.emit('terminal-input', data);
});</code></pre>
                        <p class="text-sm text-gray-500 mt-2">Integra XTerm.js para emular una terminal VT100 completa conectada al shell del contenedor.</p>
                    </div>
                </div>

            </div>
        </main>

        <footer class="text-center mt-12 py-6 border-t border-gray-200">
            <p class="text-sm text-gray-500">&copy; Arturo Vaquero Serrano. Todos los derechos reservados.</p>
        </footer>

    </div>

</body>
</html>